// Generate all item-service model code that relies on item type list:
//
//  - ItemType enumeration constants.
//  - UnmarshalJSON, String and MarshalJSON methods.

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"

	"github.com/rs/zerolog/log"
)

func main() {
	// Read item_types.txt file from current directory.
	f, err := os.Open("item_types.txt")
	defer f.Close()
	if err != nil {
		log.Fatal().Err(err).Msg("couldn't open item_types.txt")
	}
	scanner := bufio.NewScanner(f)
	parentsToTypes := map[string]string{}
	typesToParents := map[string]string{}
	itemTypes := []string{}
	prefixMap := map[string]string{}
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" {
			vals := strings.Split(line, ":")
			parentsToTypes[vals[1]] = vals[0]
			typesToParents[vals[0]] = vals[1]
			itemTypes = append(itemTypes, vals[0])
			prefixMap[vals[0]] = vals[2]
		}
	}
	if err = scanner.Err(); err != nil {
		log.Fatal().Err(err).Msg("couldn't read item_types.txt")
	}

	// Figure out which are the creatable, i.e. non-abstract item types:
	// you can create a "hotel" item, but you can't create a generic
	// "venue" item...
	creatable := []string{}
	for _, t := range itemTypes {
		if _, chk := parentsToTypes[t]; !chk {
			creatable = append(creatable, t)
		}
	}

	// Open output file.
	outf, err := os.Create("item_types_generated.go")
	if err != nil {
		log.Fatal().Err(err).Msg("couldn't create item_types_generated.go")
	}
	defer outf.Close()
	fmt.Fprintln(outf, "// Code generated by gen_item_types. DO NOT EDIT.")

	templates := []struct {
		name  string
		templ string
	}{{name: "enum", templ: enumTemplate},
		{name: "json", templ: unmarshalJSONTemplate},
		{name: "string", templ: stringTemplate},
		{name: "db", templ: dbTemplate}}
	for _, t := range templates {
		runTemplate(outf, t.name, t.templ, itemTypes)
	}
	runTemplate(outf, "creatable", creatableTemplate, creatable)
	runTemplate(outf, "prefixes", prefixTemplate, prefixMap)
}

func runTemplate(f io.Writer, name string, templ string, ts interface{}) {
	funcMap := template.FuncMap{
		"lower": strings.ToLower,
	}
	t := template.Must(template.New(name).Funcs(funcMap).
		Parse(strings.ReplaceAll(templ, "#", "`")))
	err := t.Execute(f, ts)
	if err != nil {
		log.Fatal().Err(err).Msg("failed during template generation")
	}
}

const enumTemplate string = `
package model

import (
	"database/sql/driver"
	"encoding/json"
	"strings"

	"github.com/pkg/errors"
)

// ItemType is an enumeration that represents all the known types of
// item.
type ItemType int

// Constants for all item types.
const (
	UnknownItem ItemType = iota{{range .}}
	{{.}}Item{{end}}
)
`

const unmarshalJSONTemplate string = `
// UnmarshalJSON unmarshals an item type from a JSON string.
func (it *ItemType) UnmarshalJSON(d []byte) error {
	var s string
	if err := json.Unmarshal(d, &s); err != nil {
		return errors.Wrap(err, "can't unmarshal item type")
	}
	return it.FromString(s)
}

// FromString converts a string to an item type.
func (it *ItemType) FromString(s string) error {
	switch strings.ToLower(s) {
	default:
		return errors.New("unknown item type '" + s + "'")
{{- range .}}
	case "{{lower .}}":
		*it = {{.}}Item
{{- end}}
	}
	return nil
}
`

const stringTemplate string = `
// String converts an item type from its internal representation to a
// string.
func (it ItemType) String() string {
	switch it {
	default:
		return "<unknown item type>"
{{- range .}}
	case {{.}}Item:
		return "{{lower .}}"
{{- end}}
	}
}

// MarshalJSON converts an internal item type to JSON.
func (it ItemType) MarshalJSON() ([]byte, error) {
	s := it.String()
	if s == "<unknown item type>" {
		return nil, errors.New("unknown item type")
	}
	return json.Marshal(s)
}
`

const creatableTemplate string = `
// Creatable returns whether an item type can be created, i.e. whether
// it's a non-abstract type.
func (it ItemType) Creatable() bool {
	switch it {
	default:
		return false
{{- range .}}
	case {{.}}Item:
		return true
{{- end}}
	}
}
`

const prefixTemplate string = `
// ID prefixes by item type.
var ItemTypeIDPrefixes = map[ItemType]string{
{{- range $t, $p := . }}
	{{ $t }}Item: "{{ $p }}",
{{- end}}
}
`

const dbTemplate string = `
// Scan implements the sql.Scanner interface.
func (it *ItemType) Scan(src interface{}) error {
	var s string
	switch src := src.(type) {
	case string:
		s = src
	case []byte:
		s = string(src)
	default:
		return errors.New("incompatible type for ItemType")
	}
	return it.FromString(s)
}

// Value implements the driver.Value interface.
func (it ItemType) Value() (driver.Value, error) {
	return it.String(), nil
}
`
